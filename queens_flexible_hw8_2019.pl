%               A flexible royal picnic
% We try to solve the 8-queens problem in the most naive top-down way
% possible. A queen in chess can move (and attack) vertically,
% horizontally and diagonally. Clearly it is not possible to put more
% than 8 queens that do not threaten each other on an 8x8
% chessboard. But can one put 8? If yes, how?

% We start by stipulating that a solution is a list of coordinate
% pairs. We know that all the x-coordinates must be different.
% Note that the / does not indicate division but is just another
% operator without further properties here.The fact that
% prolog does not try to do arithmetic unless ordered is used to
% advantage in that we can 'overload' the / operator and use it for our
% purpose. One could do without / and instead write a solution as a list
% of pairs as well.

:- dynamic(qn/1).      % dynamic predicates can be asserted during
:- dynamic(st/1).      % execution of the program, thus modifying
:- dynamic(kset/1).    % the program on the fly. Should be used with care
		       % I am using the dynamic predicates only to
		       % fix the size of the board and solution template.

cl :- retractall( qn(_)), retractall( st(_)), retractall(kset(_)).
		       % you have to clean up the database before you
                       % can use ksol with a different k!
                       % Note this does not seem to work perfectly
                       % if you just tack on cl after a run,
                       % then change k.
		       % To get reliable answers for various k
		       % restart prolog from the file or
		       % use cl from the prompt (that
		       % seems to do the trick as well)


ksol(K,ST) :- length(L1,K), maketemplate(L1,ST,K), kset(Kset,K),
	asserta( (qn(K))),asserta( (st(ST))), asserta( (kset(Kset)) ).
	                % number of queens, solution template
maketemplate([],[],_K).
maketemplate([X|Rest],[N1/X|RT],K) :-  maketemplate(Rest,RT,K),
	                            length([X|Rest],N),N1 is K-N+1,!.

kset([],0).
kset([N|Rest],N) :-N1 is N-1, kset(Rest,N1),!.

solution(L) :- st(L), sol(L).
% solution(L) :- L = [1/_Y1,2/_Y2,3/_Y3,4/_Y4,5/_Y5,6/_Y6,7/_Y7,8/_Y8],
% sol(L).
       % Here we use the fact that there must be one queen per X-coordinate.
       % We only have to compute the Y-coordinates.

sol([]).    % Well, placing no queen looks like a good start.
            % No attacking going on here. But we have to admit some queens.

sol([Q|Queens]) :- sol(Queens),       % If the rest of the queens are peaceful
	         % Q=_X/Y, member(Y,[1,2,3,4,5,6,7,8]),
		  Q=_X/Y, kset(Kset),member(Y,Kset),
                  noattack(Q,Queens). % and the newly admitted Q does not
                                      % attack the old Queens, we are on course.
				      % Of course, we have to define the
                                      % noattack relation.

noattack(_Q,[]).                     % A queen does not attack the void.
                                     % A queen is not attacked by the void.

noattack(Q,[Q1|Qs]) :-   noatt(Q,Q1),% Still putting off the hard work.
    noattack(Q,Qs).    % But, indeed, if Q does not attack
                                     % each single Queen in the list we are ok.

noatt(X/Y, X1/Y1) :-   X =\= X1, Y =\= Y1, X-X1 =\= Y-Y1, X-X1 =\= Y1-Y .
				     % What is this blue =\= ?


% Can we visualize the board of queens of a solution?
writeb(Board) :- wb(1,Board). %The 'Board' here should  be an 'L' from solution(L).

wb(Y,_Board) :-	 qn(Y0), Y>=Y0+1.                    %  Y>=9,!.
wb(YR,Board)  :- wyr(1,YR,Board),YR1 is YR+1,wb(YR1,Board),!.

wyr(X,Y,_Board) :- qn(X0), X>=X0+1, write('|'), write('  '), writeln(Y),!.
wyr(X,Y,Board) :- member(X/Y,Board),write('|Q'),X1 is X+1, wyr(X1,Y,Board),!.
wyr(X,Y,Board) :- write('|_'), X1 is X+1, wyr(X1,Y,Board),!.

% How many solutions are generated by ; ?
% How do you use writeb to display solutions?
% The board looks incomplete.
% Modify the program so that the board displayed has
% lids on top (this does not require fancy programming).
% Modify the program to find solutions for
% n queens on an nxn board for n=1,...,7 or
% to provide evidence that no such solution exists for this n.
% Use an appropriately modified writeb to display your solutions.
%
% ------------------------------------------------------------------------
% Homework #8
% Kilian Rick
% Date: 5/11/19
%
%
% 4)
% a) for 8 queens, 92 solutions are generated
%
% b)
allsol(L):- findall(A,solution(A),L).
noofallsol(I):- findall(A,solution(A),L), length(L,I).
%?- allsol(L).
% L = [[1/5, 2/7, 3/2, 4/6, 5/3, 6/1, 7/4, ... / ...], [1/4, 2/7, 3/5,
% 4/2, 5/6, 6/1, ... / ...|...], [1/6, 2/4, 3/7, 4/1, 5/3, ... /
% ...|...], [1/6, 2/3, 3/5, 4/7, ... / ...|...], [1/4, 2/2, 3/8, ... /
% ...|...], [1/5, 2/3, ... / ...|...], [1/6, ... / ...|...], [... /
% ...|...], [...|...]|...].
%?- noofallsol(L).
%L = 92.
%c)
%the input has to be the list L archieved by calling solution(L)
writesol() :- solution(L), writeb(L),!.

%d)PROGRAM CYCLES DO NOT TEST!
nwritesol() :- solution(L), nwriteb(L),!.
nwriteb(Board) :- nwb(1,Board). %The 'Board' here should  be an 'L' from solution(L).


nwb(Y,_Board) :-	 qn(Y0), Y>=Y0+1.                    %  Y>=9,!.
nwb(YR,Board)  :- nwyr(1,YR,1),nwb(YR,Board).
nwb(YR,Board)  :- nwyr(1,YR,Board),YR1 is YR+1,nwb(YR1,Board),!.

nwyr(X,Y,_Board) :- qn(X0), X>=X0+1, write('|'), write('  '), writeln(Y),!.
nwyr(X,Y,Board) :- member(X/Y,Board),write('|Q'),X1 is X+1, nwyr(X1,Y,Board),!.
nwyr(X,Y,Board) :- write('|_'), X1 is X+1, nwyr(X1,Y,Board),!.



